---
```cpp
   650:     errno = 0; 
0x08000AE4 F001F8C8  BL.W     0x08001C78 __aeabi_errno_addr 
// в регистр r1 заносится значение 0 – это значение, которое присваивается errno
0x08000AE8 2100      MOVS     r1,#0x00	
// значение из регистра r1 сохраняется по адресу, вычисленному как r0+0 – это сохранение значения // errno
0x08000AEA 6001      STR      r1,[r0,#0x00]
```

>Как вы изящно пропустили разбор первой строчки, где BL.W ;) Есть предположения, что там происходит?

Это переход в функцию __aeabi_errno_addr, листинг тела которой имеет вид:
```cpp
0x08001CE4 4800      LDR      r0,[pc,#0]  ; @0x08001CE8
// в регистр r0 загружается значение из памяти по адресу pc+0 - загрузка в r0 адреса переменной errno
0x08001CE6 4770      BX       lr
// выход из функции
```
---
```cpp
// команда-подсказка, не делающая ничего – достигнуто break;
0x08000614 BF00      NOP
```
> И о чем же она подсказывает?

Видимо, я не правильно перевел слово hint в документации:) Это просто команда, не делающая ничего, которая применяется для
разных целей. К счастью или сожалению, я уже услышал, как Вы кому-то отвечали по поводу ее использования, и могу
сказать, что здесь эта команда нужна для установки на break точки останова, т.к. для ее установки нужно соответствие
строки в коде какой-то ассемблерной команды.

---
```cpp
// вычисление sp - ZeroExtend(0x10:’00’, 32)  и занесение результата в регистр sp – переход 
// указателя стека
0x08000852 B084      SUB      sp,sp,#0x10
```

> Ээээ а откуда тут вдруг какой-то ZeroExtend?

Видимо, я уже хотел спать и смешал значение непосредственного
операнда с ее представлением в ассемблерной команде, конечно,
там просто sp - 0x10

---

>>    Теперь рассмотрим листинг функции isTrue_64. Основные отличия следующие:
>>    Изменены арифметические операции (в примере описано сложение ):

>А как изменились остальные арифметические операции?

Сложение рассмотрено в отчете, остальные операции
для isTrue_64 следующие:

1) Вычитание:
```cpp
252: *result = num1 - num2;
// вычислить r4-r2 и записать в r1 с выставлением флагов - 
// вычесть младшие байты чисел и записать в r1
0x080004CC 1AA1 SUBS r1,r4,r2

// вычислить r5-r3 с учетом заема и записать в r0 - 
// вычесть старшие байты чисел и записать в r0
0x080004CE EB650003 SBC r0,r5,r3

// сохранить в память r1 и r0 по адресу в r6 - 
// записать результат в переменную
0x080004D2 E9C61000 STRD r1,r0,[r6,#0]
```

2) Умножение

```cpp
269: *result = num1 * num2;
// беззнаково умножить r4*r6 и записать r0 и r1 - 
// умножить младшие байты множителей и записать в r0 и r1
0x08000576 FBA40106 UMULL r0,r1,r4,r6

// вычислить r5*r6+r1 и записать в r1 - 
// умножить младший байт одного числа на старший байт другого числа
// и увеличить старший байт результата на это число
0x0800057A FB051106 MLA r1,r5,r6,r1

// вычислить r4*r7+r1 и записать в r1 - 
// умножить старший байт одного числа на младший байт другого числа
// и увеличить старший байт результата на это число
0x0800057E FB041107 MLA r1,r4,r7,r1

// сохранить r0 и r1 в память по адресу r8 - 
// сохранить результат в переменную
0x08000582 E9C80100 STRD r0,r1,[r8,#0]

// умножать старшие байты нет необходимости, поскольку результат
// их умножения гарантированно выйдет за пределы
// разрядной сетки
```

3) Деление

```cpp
282: *result = num1 / num2;
0x080005C6 4622 MOV r2,r4
0x080005C8 462B MOV r3,r5
0x080005CA 4630 MOV r0,r6
0x080005CC 4639 MOV r1,r7
// вызов подпрограммы для деления
0x080005CE F000FC7B BL.W 0x08000EC8 __aeabi_ldivmod
0x080005D2 E9C80100 STRD r0,r1,[r8,#0]
```

---


>>По позиции states можно сказать, что вычисления с float занимают больше времени, чем с int32_t.

>А насколько больше? А почему? А если на вход подать другие
строки - поменяется ли что-нибудь? :)

Я проверил на разных строках, обычно число тактов на float примерно
в 1.5 раза больше, чем на int32. Это объясняется прежде всего
сложностью операций с типом float, для которых зачастую вызывается
специальная подпрограмма, а не последовательность нескольких относительно
простых команд.
---
Часть 2
---
>>Видимо, я не правильно перевел слово hint в документации:)

>А можно цитату?

Вот так выглядит описание этой команды:
>No Operation does nothing.
This is a NOP-compatible hint, the architected NOP, see NOP-compatible hints on page A7-215.

Описание же NOP-compatible hints выглядит следующим образом:
>Hint instructions that are not associated with memory accesses are part of a separate category of hint
instructions known as NOP-compatible hints. NOP-compatible hints provide IMPLEMENTATION DEFINED
behavior or act as a NOP.

Я понимаю, что hint instructions, к которым относится NOP, специальные команды, не связанные с доступом к памяти.
Но почему они hint, я, честно говоря, не особо понимаю.

---
>Ну, если вы услышали это, то может быть вспомните и некоторые другие причины для появления NOP в коде? ;)

Он может нужен для создания задержки в целях синхронизации с другими устройствами,
для заполнения места в памяти при выравнивании адресов команд, для улучшения работы вычислительного
конвейера (что бы это на данный момент для меня не значило).

---
>Хорошо! Но имейте в виду - с точки зрения проведения эксперимента, поскольку вы не приводите ни условий, ни количество попыток, ваши результаты не повторяемы :(
>Это типа, рецепт для плохой науки.

Хорошо, мои результаты следующие:
```cpp
isTrue("200>100");                      // 3885
isTrue_float("200>100");                // 6198


isTrue("200+100>100");                  // 5578
isTrue_float("200+100>100");            // 9144

isTrue("200-100>100");                  // 5697
isTrue_float("200-100>100");            // 9283

isTrue("200*100>100");                  // 5813
isTrue_float("200*100>100");            // 9365

isTrue("200/100>100");                  // 5917
isTrue_float("200/100>100");            // 9688


isTrue("2000+1000>1000+2000");          // 8445
isTrue_float("2000+1000>1000+2000");    // 13437

isTrue("2000-1000>1000+2000");          // 8584 
isTrue_float("2000-1000>1000+2000");    // 13596

isTrue("2000*1000>1000+2000");          // 8722
isTrue_float("2000*1000>1000+2000");    // 13700

isTrue("2000/1000>1000+2000");          // 8848
isTrue_float("2000/1000>1000+2000");    // 14045
```
В комментариях напротив вызовов команды указано число тактов, затрачиваемых на эту функцию.
В среднем для float было затрачено в 1,60 раз больше тактов, чем для int32.
---
>Интересно! А почему из этих трех команд только одна - UMULL - выдает 64-битный результат? Ведь при умножении int32 на int32 результат может и не поместиться в int32 - но команды MLA этот факт игнорируют!

Нет смысла сохранять старший байт результата команды MLA, потому что он все равно не влезет в результирующую переменную.
Ну то есть т.к. эта команда используется для умножения старшего байта одного числа и младшего байта
другого числа, результат такого умножения будет в общем случае лежать в старшем байте переменной типа int64 и еще одном байте, который будет старше старшего и
не влезет в эту переменную.